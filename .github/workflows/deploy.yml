# Deployment Pipeline with Rollback
# Deploy autom√°tico a producci√≥n con capacidad de rollback

name: Deploy to Production

on:
  push:
    branches: [main]
    tags: ['v*']
  workflow_dispatch:
    inputs:
      rollback_to:
        description: 'Tag/commit para rollback (ej: v2.0.0)'
        required: false
        default: ''

env:
  NODE_ENV: production
  SSH_HOST: ${{ secrets.STADIUM_SSH_HOST }}
  SSH_PORT: ${{ secrets.STADIUM_SSH_PORT }}
  SSH_USER: ${{ secrets.STADIUM_SSH_USER }}
  DEPLOY_PATH: /home/aisrvadmin/stadium-dashboard
  PM2_APP_NAME: stadium-dashboard

jobs:
  # ============================================
  # JOB: Build for Production
  # ============================================
  build:
    name: üèóÔ∏è Build for Production
    runs-on: ubuntu-latest
    if: github.event.inputs.rollback_to == ''

    outputs:
      version: ${{ steps.version.outputs.version }}
      sha: ${{ github.sha }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get version
        id: version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION="$(date +%Y%m%d)-${GITHUB_SHA::7}"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "üì¶ Version: $VERSION"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --production=false

      - name: Run tests
        run: npm run test -- --ci --passWithNoTests || echo "‚ö†Ô∏è Tests failed but continuing deployment"
        env:
          CI: true
          NODE_ENV: test

      - name: Build application
        run: npm run build

      - name: Create deployment package
        run: |
          # Crear directorio de deploy
          mkdir -p deploy-package

          # Copiar archivos necesarios
          cp -r .next deploy-package/
          cp -r public deploy-package/
          cp package.json deploy-package/
          cp package-lock.json deploy-package/

          # Crear archivo de versi√≥n
          echo "${{ steps.version.outputs.version }}" > deploy-package/VERSION
          echo "${{ github.sha }}" >> deploy-package/VERSION
          echo "$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> deploy-package/VERSION

          # Comprimir
          tar -czf deploy-package.tar.gz deploy-package

      - name: Upload deployment package
        uses: actions/upload-artifact@v4
        with:
          name: deploy-package
          path: deploy-package.tar.gz
          retention-days: 30

  # ============================================
  # JOB: Deploy
  # ============================================
  deploy:
    name: üöÄ Deploy to Production
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: production
      url: http://${{ env.SSH_HOST }}:3000

    steps:
      - name: Download deployment package
        uses: actions/download-artifact@v4
        with:
          name: deploy-package

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.STADIUM_SSH_PRIVATE_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -p ${{ env.SSH_PORT }} ${{ env.SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Create backup on server
        run: |
          ssh -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} << 'ENDSSH'
            set -e
            cd ${{ env.DEPLOY_PATH }}

            # Crear directorio de backups si no existe
            mkdir -p backups

            # Backup del deployment actual
            if [ -f VERSION ]; then
              CURRENT_VERSION=$(head -1 VERSION)
              BACKUP_NAME="backup-${CURRENT_VERSION}-$(date +%Y%m%d-%H%M%S)"
              echo "üì¶ Creating backup: $BACKUP_NAME"

              # Guardar .next actual y package.json
              tar -czf "backups/${BACKUP_NAME}.tar.gz" \
                .next \
                public \
                package.json \
                package-lock.json \
                VERSION \
                2>/dev/null || true

              # Mantener solo √∫ltimos 5 backups
              ls -t backups/*.tar.gz 2>/dev/null | tail -n +6 | xargs rm -f 2>/dev/null || true
              echo "‚úÖ Backup created"
            else
              echo "‚ö†Ô∏è No VERSION file found, skipping backup"
            fi
          ENDSSH

      - name: Upload and extract package
        run: |
          # Upload
          scp -P ${{ env.SSH_PORT }} deploy-package.tar.gz \
            ${{ env.SSH_USER }}@${{ env.SSH_HOST }}:/tmp/

          # Extract
          ssh -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} << 'ENDSSH'
            set -e
            cd ${{ env.DEPLOY_PATH }}

            echo "üì¶ Extracting deployment package..."
            tar -xzf /tmp/deploy-package.tar.gz --strip-components=1
            rm /tmp/deploy-package.tar.gz

            echo "üì• Installing production dependencies..."
            npm ci --production

            echo "‚úÖ Package extracted and dependencies installed"
          ENDSSH

      - name: Restart application
        run: |
          ssh -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} << 'ENDSSH'
            set -e
            cd ${{ env.DEPLOY_PATH }}

            echo "üîÑ Restarting PM2 process..."
            pm2 reload ${{ env.PM2_APP_NAME }} --update-env || pm2 start npm --name "${{ env.PM2_APP_NAME }}" -- start

            echo "‚è≥ Waiting for app to be ready..."
            sleep 5

            # Health check
            for i in 1 2 3 4 5; do
              if curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/api/auth/me | grep -q "401\|200"; then
                echo "‚úÖ Application is healthy!"
                pm2 save
                exit 0
              fi
              echo "‚è≥ Attempt $i/5 - waiting..."
              sleep 3
            done

            echo "‚ùå Health check failed!"
            exit 1
          ENDSSH

      - name: Verify deployment
        run: |
          ssh -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} << 'ENDSSH'
            cd ${{ env.DEPLOY_PATH }}
            echo "üìä Deployment Info:"
            echo "===================="
            cat VERSION
            echo ""
            echo "üìä PM2 Status:"
            pm2 show ${{ env.PM2_APP_NAME }} | head -20
          ENDSSH

      - name: Send notification on success
        if: success()
        run: |
          echo "‚úÖ Deployment successful!"
          echo "Version: ${{ needs.build.outputs.version }}"
          echo "Commit: ${{ needs.build.outputs.sha }}"
          # Aqu√≠ se puede agregar notificaci√≥n a Slack, Discord, etc.

  # ============================================
  # JOB: Rollback
  # ============================================
  rollback:
    name: ‚è™ Rollback
    runs-on: ubuntu-latest
    if: github.event.inputs.rollback_to != ''
    environment:
      name: production

    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.STADIUM_SSH_PRIVATE_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -p ${{ env.SSH_PORT }} ${{ env.SSH_HOST }} >> ~/.ssh/known_hosts

      - name: List available backups
        id: list-backups
        run: |
          ssh -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} << 'ENDSSH'
            echo "üì¶ Available backups:"
            ls -la ${{ env.DEPLOY_PATH }}/backups/*.tar.gz 2>/dev/null || echo "No backups found"
          ENDSSH

      - name: Execute rollback
        run: |
          ssh -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} << 'ENDSSH'
            set -e
            cd ${{ env.DEPLOY_PATH }}

            ROLLBACK_TARGET="${{ github.event.inputs.rollback_to }}"
            echo "‚è™ Rolling back to: $ROLLBACK_TARGET"

            # Buscar backup
            BACKUP_FILE=$(ls -t backups/*${ROLLBACK_TARGET}*.tar.gz 2>/dev/null | head -1)

            if [ -z "$BACKUP_FILE" ]; then
              echo "‚ùå Backup not found for: $ROLLBACK_TARGET"
              echo "Available backups:"
              ls backups/*.tar.gz 2>/dev/null || echo "No backups found"
              exit 1
            fi

            echo "üì¶ Using backup: $BACKUP_FILE"

            # Crear backup del estado actual antes de rollback
            CURRENT_BACKUP="backups/pre-rollback-$(date +%Y%m%d-%H%M%S).tar.gz"
            tar -czf "$CURRENT_BACKUP" .next public package.json VERSION 2>/dev/null || true

            # Extraer backup
            tar -xzf "$BACKUP_FILE"

            # Reinstalar dependencias
            npm ci --production

            # Restart
            pm2 reload ${{ env.PM2_APP_NAME }} --update-env

            echo "‚è≥ Waiting for app to be ready..."
            sleep 5

            # Health check
            if curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/api/auth/me | grep -q "401\|200"; then
              echo "‚úÖ Rollback successful!"
              pm2 save
            else
              echo "‚ùå Rollback failed health check!"
              exit 1
            fi
          ENDSSH

      - name: Verify rollback
        run: |
          ssh -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} << 'ENDSSH'
            cd ${{ env.DEPLOY_PATH }}
            echo "üìä Rollback Info:"
            echo "===================="
            cat VERSION
            echo ""
            pm2 show ${{ env.PM2_APP_NAME }} | head -15
          ENDSSH

  # ============================================
  # JOB: Cleanup on Failure
  # ============================================
  cleanup-on-failure:
    name: üßπ Cleanup on Failure
    runs-on: ubuntu-latest
    needs: deploy
    if: failure()

    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.STADIUM_SSH_PRIVATE_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -p ${{ env.SSH_PORT }} ${{ env.SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Attempt auto-rollback
        run: |
          ssh -p ${{ env.SSH_PORT }} ${{ env.SSH_USER }}@${{ env.SSH_HOST }} << 'ENDSSH'
            set -e
            cd ${{ env.DEPLOY_PATH }}

            echo "üö® Deployment failed, attempting auto-rollback..."

            # Encontrar √∫ltimo backup v√°lido
            LAST_BACKUP=$(ls -t backups/*.tar.gz 2>/dev/null | head -1)

            if [ -z "$LAST_BACKUP" ]; then
              echo "‚ùå No backup available for auto-rollback"
              exit 1
            fi

            echo "‚è™ Rolling back to: $LAST_BACKUP"
            tar -xzf "$LAST_BACKUP"
            npm ci --production
            pm2 reload ${{ env.PM2_APP_NAME }} --update-env
            pm2 save

            echo "‚úÖ Auto-rollback completed"
          ENDSSH
